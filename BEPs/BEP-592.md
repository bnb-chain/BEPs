<pre>
  BEP: 592
  Title: Non-Consensus Based Block-Level Access List
  Status: Draft
  Type: Standards
  Created: 2025-06-30
  Description: Generate block access list and propgate it along with block to accelerate block execution.
</pre>

# BEP-592: Non-Consensus Based Block-Level Access List
- [BEP-592: Non-Consensus Based Block-Level Access List](#bep-592-non-consensus-based-block-level-access-list)
  - [1. Summary](#1-summary)
  - [2. Status](#2-status)
  - [3. Motivation](#3-motivation)
  - [4. Specification](#4-specification)
    - [4.1 Parameters](#41-parameters)
    - [4.2 Data Structure](#42-data-structure)
    - [4.3 BAL Generation](#43-bal-generation)
    - [4.4 BAL Propagation](#44-bal-propagation)
    - [4.5 BAL Storage](#45-bal-storage)
    - [4.6 BAL Execution](#46-bal-execution)
  - [5. Rationale](#5-rationale)
    - [5.1.Why not include the slot value in BAL?](#51why-not-include-the-slot-value-in-bal)
    - [5.2.Why not define a new block header element for BAL?](#52why-not-define-a-new-block-header-element-for-bal)
    - [5.3.Any incentive/slash for a validator to generate BAL?](#53any-incentiveslash-for-a-validator-to-generate-bal)
  - [6. Forward Compatibility](#6-forward-compatibility)
  - [7. Backward Compatibility](#7-backward-compatibility)
  - [8. License](#8-license)

## 1. Summary

This BEP aims to improve performance by implementing BAL(Block-Level Access List), which will include some meta data in blocks to help accelerate block execution by load storage into cache in advance concurrently.

## 2. Status

Draft

## 3. Motivation

To increase BSC's performance by providing the access list during the mining phase. With shorter block internal and increasing throughput, faster block importing could be very useful, especially to:
- MEV: builder can simulate new bids earlier.
- Fast Finality: validators can cast vote earlier.
- Validators: they would have more time to mine the first consecutive block.
- Other Full Nodes: better performance to catch up to the latest block.

## 4. Specification
### 4.1 Parameters

| Constant | Value |
| - | - |
| `MAX_BAL_BYTES` | `1048576` |
| `MIN_SECONDS_FOR_BAL` | `1572480` |

### 4.2 Data Structure
Due to backward/forward compatibility concern, as the first of BAL, the data structure of the block header and body will stay unchanged. The BAL content will be simply attached to the end of the block as an optional component.
![](assets/BEP-592/bal-asset-1.png)

Here is the data structure of BAL:
```go
// AccountAccessList is a list of accounts and their storage keys that are accessed in a block.
type AccountAccessList struct {
    Address     common.Address
    StorageKeys []common.Hash
}

// BlockAccessList is a list of accounts and their storage keys that are accessed in a block.
type BlockAccessList struct {
    Version  uint64               // Version of the access list format
    Accounts []AccountAccessList
}
```
The version element will be used for future protocol upgrades, it will be starting from version zero.
The final content will be RLP encoded, as it is BSC's current main encoding schema(but it could be ssz based, to be determined)

### 4.3 BAL Generation
Validator will be responsible to generate the BAL content, as it would execute transaction one by one to create a block, it knows exactly the accounts and storage slots that the block will access. Validator could keep these access list, encode it and attach to the end of the block.

There would be size limitations on BAL, the BAL doesn't need to include 100% of the block's access list, the size can not exceed `MAX_BAL_BYTES`.

### 4.4 BAL Propagation
BAL will be propagated as part of the block, but it would only be propagated within EVN(Enhanced Validator Network) to avoid massive P2P traffic on public network.

### 4.5 BAL Storage
As BAL is mainly to speed up the block import, it is optional and as it has considerable size, it is not necessary for nodes to persist all the historical BAL data. To make it simply, use the same rule as blob data, nodes can just keep BALs for `MIN_SECONDS_FOR_BAL` seconds.

### 4.6 BAL Execution
As BAL version zero is non-consensus based, it is not required to verify the validity of BAL. On receving the BAL, nodes can concurently load the accounts and slots into cache to speed of the block execution.

## 5. Rationale

### 5.1.Why not include the slot value in BAL?
Mainly to keep BAL small, let's assume a block with 200 Txs, each accessed 50 storage slots, that would be around 10K slots in total, that would be 320KB to keep the slot key.
And in order to make sure the storage value is correct the MPT proof would be needed, which would further increase the size of BAL.

### 5.2.Why not define a new block header element for BAL?
It could be considered in the future, but at the first stage, we would prefer to keep it simple to avoid some compatibility issues.
![](assets/BEP-592/bal-asset-2.png)

### 5.3.Any incentive/slash for a validator to generate BAL?
At the first stage, there is no incentive or slash mechanism, it depends on the validator's willingness to provide the BAL. Validators may not have the motivation to maliciously construct the BAL, even so the impact is supposed to be limited as the BAL is mainly used for state preload and size of BAL is limited.

## 6. Forward Compatibility
TBD

## 7. Backward Compatibility
TBD

## 8. License

The content is licensed under [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
