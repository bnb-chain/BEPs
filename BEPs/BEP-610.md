<pre>
  BEP: 610
  Title: Implement EVM Super Instruction
  Status: Draft
  Type: Standards
  Created: 2025-08-12
  Description: It defines several customized super instruction opcodes to replace high frequency EVM opcode sequences to improve performance
</pre>

# BEP-610: Implement EVM Super Instruction

- [BEP-610: Implement EVM Super Instruction](#bep-610-implement-EVM-Super-Instruction)
  - [1. Abstract](#1-abstract)
  - [2. Motivation](#2-motivation)
  - [3. Specification](#3-specification)
    - [3.1 Optimized Bytecode Generation (Background)](#31-optimized-bytecode-generation-background)
    - [3.2 Super-Instruction Execution (Foreground)](#32-super-instruction-execution-foreground)
    - [3.3 Super-Instruction Set Generation](#33-super-instruction-set-generation)
    - [3.4 Compatibility & Safety](#34-compatibility--safety)
    - [3.5 Security Considerations](#35-security-considerations)
  - [4. Backwards Compatibility](#4-backwards-compatibility)
  - [5. License](#5-license)

## 1. Abstract
This BEP introduces several customized super instruction opcodes to replace high frequency EVM opcode sequences to improve performance. Contract byte code is pre-processed to convert some sequence of EVM opcodes to super instruction opcodes and the EVM interpreter executes these super instruction opcode atomically. The approach yields significant execution-layer efficiency without altering consensus rules or requiring a hard-fork.

## 2. Motivation

On BSC mainnet, repeated execution of identical compiler-generated instruction patterns dominates gas consumption. By fusing these hot paths into single interpreter dispatches, we:

- Reduce opcode dispatch overhead
- Minimise stack shuffling
- Achieve measurable throughput gains without protocol change.

## 3. Specification

### 3.1 Optimized Bytecode Generation (Background)

| Aspect | Design                                                                                                                                                              |
|--------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Feature Toggle | Node flag `--vm.opcode.optimize` (default false). When disabled, the optimisation pipeline becomes a no-op.                                                         |
| Workflow | codeHash lookup -> LRU cache hit -> use optimised code. Cache miss -> (codeHash, rawCode) pushed to lock-free queue.                                                |
| Basic-Block Construction | Split at PC==0 or any JUMPDEST; terminate before {JUMP, JUMPI, STOP, RETURN, REVERT, INVALID}.                                                                      |
| Pattern Matching & Fusion | Sliding window (1-15 bytes) matches curated patterns; first byte replaced by custom opcode 0xb0–0xcf, trailing bytes overwritten with NOP(0x5b) to preserve length. |
| Cache | (codeHash -> fusedCode) stored in in-memory LRU (64 k entries default). Auxiliary static-analysis bitvectors stored in a side-cache.                                |

### 3.2 Super-Instruction Execution (Foreground)

| Phase | Description                                                                                                                                                     |
|-------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Loading | Before execution, interpreter queries cache with codeHash. Hit -> contract flagged optimized = true, fused bytecode loaded. Miss -> original bytecode executed. |
| Dispatch | Main loop processes opcodes as usual. For newly added superinstruction opcodes, jump directly to Super-Instruction handler.                                     |
| Semantics | Handler emulates entire sequence (e.g., AND DUP2 ADD SWAP1 DUP2 LT) in one step, adjusts PC by original length, validates jump targets when applicable.         |
| Safety | If custom opcode appears in non-optimised contract, throw ErrIllegalSuperInst and revert.                                                                       |

### 3.3 Super-Instruction Set Generation

| Process | Description |
|---------|-------------|
| Data-Driven Mining | Trace production traffic, extract opcode sequences, compress with Re-Pair to obtain non-repetitive string. |
| Scoring | `score = len(sequence) × frequency` |
| Overlap Resolution | Greedy graph algorithm adjusts scores when super-instructions overlap (A ⊂ B). |
| Selection | Choose Top-K sequences (32 by default) as canonical super-instruction sets. |

### 3.4 Compatibility & Safety
| Aspect | Guarantee                                                                      |
|--------|--------------------------------------------------------------------------------|
| Switchable | Runtime flag permits instant enable/disable without restart.                   |
| Length-Preserving | Fused bytecode matches original size; all offset-based tooling remains intact. |
| Consensus Neutral | Only local execution changes; on-chain code unmodified -> no consensus impact. |
| Graceful Fallback | Failure in generation/execution reverts to original code path.                 |

### 3.5. Security Considerations

- **Validator Nodes**: Opt-in optimisation must not diverge state; test-suite includes differential fuzzing against vanilla EVM.
- **Custom Opcode Collision**: Range 0xb0–0xcf currently unused by London EVM; future EIPs allocating these bytes must be gated by network governance before activation.
- **DoS Risk**: Background optimiser bounded by worker pool and queue length to avoid unbounded memory/CPU spikes.

## 4. Backwards Compatibility
Because bytecode length and on-chain contents remain unchanged, no tooling or contract migration is necessary. Nodes that disable the flag continue to operate identically, ensuring a smooth opt-in rollout.

## 5. License
All the content are licensed under CC0.
