<pre>
  BEP: 610
  Title: Implement EVM Super Instruction
  Status: Draft
  Type: Standards
  Created: 2025-08-12
  Description: It defines several customized super instruction opcodes to replace high frequency EVM opcode sequences to improve performance
</pre>

# BEP-610: Implement EVM Super Instruction

- [BEP-610: Implement EVM Super Instruction](#bep-610-implement-EVM-Super-Instruction)
  - [1. Abstract](#1-abstract)
  - [2. Motivation](#2-motivation)
  - [3. Specification](#3-specification)
    - [3.1 Super Instruction opcode definition ](#31-super-instruction-opcode-definition)
    - [3.2 Optimized Bytecode Generation (Background)](#32-optimized-bytecode-generation-background)
    - [3.3 Super-Instruction Execution (Foreground)](#33-super-instruction-execution-foreground)
    - [3.4 Super-Instruction Set Generation](#34-super-instruction-set-generation)
    - [3.5 Compatibility & Safety](#35-compatibility--safety)
    - [3.6 Security Considerations](#36-security-considerations)
  - [4. Backwards Compatibility](#4-backwards-compatibility)
  - [5. License](#5-license)

## 1. Abstract
This BEP introduces several customized super instruction opcodes to replace high frequency EVM opcode sequences to improve performance. Contract byte code is pre-processed to convert some sequence of EVM opcodes to super instruction opcodes and the EVM interpreter executes these super instruction opcode atomically. The approach yields significant execution-layer efficiency without altering consensus rules or requiring a hard-fork.

## 2. Motivation

On BSC mainnet, repeated execution of identical compiler-generated instruction patterns dominates gas consumption. By fusing these hot paths into single interpreter dispatches, we:

- Reduce opcode dispatch overhead
- Minimise stack shuffling
- Achieve measurable throughput gains without protocol change.

## 3. Specification

### 3.1 Super Instruction opcode definition

| Index (Hex) | Super Instruction                             |
|-------------|-----------------------------------------------------|
| 0xb1        | AndSwap1PopSwap2Swap1                               |
| 0xb2        | Swap2Swap1PopJump                                   |
| 0xb3        | Swap1PopSwap2Swap1                                  |
| 0xb4        | PopSwap2Swap1Pop                                    |
| 0xb5        | Push2Jump                                           |
| 0xb6        | Push2JumpI                                          |
| 0xb7        | Push1Push1                                          |
| 0xb8        | Push1Add                                            |
| 0xb9        | Push1Shl                                            |
| 0xba        | Push1Dup1                                           |
| 0xbb        | Swap1Pop                                            |
| 0xbc        | PopJump                                             |
| 0xbd        | Pop2                                                |
| 0xbe        | Swap2Swap1                                          |
| 0xbf        | Swap2Pop                                            |
| 0xc0        | Dup2LT                                              |
| 0xc1        | JumpIfZero                                          |
| 0xc2        | IsZeroPush2                                         |
| 0xc3        | Dup2MStorePush1Add                                  |
| 0xc4        | Dup1Push4EqPush2                                    |
| 0xc5        | Push1CalldataloadPush1ShrDup1Push4GtPush2           |
| 0xc6        | Push1Push1Push1SHLSub                               |
| 0xc7        | AndDup2AddSwap1Dup2LT                               |
| 0xc8        | Swap1Push1Dup1NotSwap2AddAndDup2AddSwap1Dup2LT      |
| 0xc9        | Dup3And                                             |
| 0xca        | Swap2Swap1Dup3SubSwap2Dup3GtPush2                   |
| 0xcb        | Swap1Dup2                                           |
| 0xcc        | SHRSHRDup1MulDup1                                   |
| 0xcd        | Swap3PopPopPop                                      |
| 0xce        | SubSLTIsZeroPush2                                   |
| 0xcf        | Dup11MulDup3SubMulDup1                              |

### 3.2 Optimized Bytecode Generation (Background)

| Aspect | Design                                                                                                                                                              |
|--------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Feature Toggle | Node flag `--vm.opcode.optimize` (default false). When disabled, the optimisation pipeline becomes a no-op.                                                         |
| Workflow | codeHash lookup -> LRU cache hit -> use optimised code. Cache miss -> (codeHash, rawCode) pushed to lock-free queue.                                                |
| Basic-Block Construction | Split at PC==0 or any JUMPDEST; terminate before {JUMP, JUMPI, STOP, RETURN, REVERT, INVALID}.                                                                      |
| Pattern Matching & Fusion | Sliding window (1-15 bytes) matches curated patterns; first byte replaced by custom opcode 0xb0–0xcf, trailing bytes overwritten with NOP(0x5b) to preserve length. |
| Cache | (codeHash -> fusedCode) stored in in-memory LRU (64 k entries default). Auxiliary static-analysis bitvectors stored in a side-cache.                                |

### 3.3 Super-Instruction Execution (Foreground)

| Phase | Description                                                                                                                                                     |
|-------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Loading | Before execution, interpreter queries cache with codeHash. Hit -> contract flagged optimized = true, fused bytecode loaded. Miss -> original bytecode executed. |
| Dispatch | Main loop processes opcodes as usual. For newly added superinstruction opcodes, jump directly to Super-Instruction handler.                                     |
| Semantics | Handler emulates entire sequence (e.g., AND DUP2 ADD SWAP1 DUP2 LT) in one step, adjusts PC by original length, validates jump targets when applicable.         |
| Safety | If custom opcode appears in non-optimised contract, throw ErrIllegalSuperInst and revert.                                                                       |

### 3.4 Super-Instruction Set Generation

| Process | Description |
|---------|-------------|
| Data-Driven Mining | Trace production traffic, extract opcode sequences, compress with Re-Pair to obtain non-repetitive string. |
| Scoring | `score = len(sequence) × frequency` |
| Overlap Resolution | Greedy graph algorithm adjusts scores when super-instructions overlap (A ⊂ B). |
| Selection | Choose Top-K sequences (32 by default) as canonical super-instruction sets. |

### 3.5 Compatibility & Safety
| Aspect | Guarantee                                                                      |
|--------|--------------------------------------------------------------------------------|
| Switchable | Runtime flag permits instant enable/disable without restart.                   |
| Length-Preserving | Fused bytecode matches original size; all offset-based tooling remains intact. |
| Consensus Neutral | Only local execution changes; on-chain code unmodified -> no consensus impact. |
| Graceful Fallback | Failure in generation/execution reverts to original code path.                 |

### 3.6 Security Considerations

- **Validator Nodes**: Opt-in optimisation must not diverge state; test-suite includes differential fuzzing against vanilla EVM.
- **Custom Opcode Collision**: Range 0xb0–0xcf currently unused by London EVM; future EIPs allocating these bytes must be gated by network governance before activation.
- **DoS Risk**: Background optimiser bounded by worker pool and queue length to avoid unbounded memory/CPU spikes.

## 4. Backwards Compatibility
Because bytecode length and on-chain contents remain unchanged, no tooling or contract migration is necessary. Nodes that disable the flag continue to operate identically, ensuring a smooth opt-in rollout.

## 5. License
All the content are licensed under CC0.
