<pre>
  BEP: 610
  Title: Smart-Contract Bytecode Optimization & Super-Instruction Execution
  Status: Draft
  Type: Standards
  Created: 2025-08-12
  Description: Custom single-byte opcodes to replace high-frequency EVM opcode sequences
</pre>

# BEP-610: Smart-Contract Bytecode Optimization & Super-Instruction Execution

- [BEP-610: Smart-Contract Bytecode Optimization & Super-Instruction Execution](#bep-610-smart-contract-bytecode-optimization--super-instruction-execution)
  - [1. Abstract](#1-abstract)
  - [2. Status](#2-status)
  - [3. Motivation](#3-motivation)
  - [4. Specification](#4-specification)
    - [4.1 Optimized Bytecode Generation (Background)](#41-optimized-bytecode-generation-background)
    - [4.2 Super-Instruction Execution (Foreground)](#42-super-instruction-execution-foreground)
    - [4.3 Super-Instruction Set Generation](#43-super-instruction-set-generation)
  - [5. Compatibility & Safety](#5-compatibility--safety)
  - [6. Backwards Compatibility](#6-backwards-compatibility)
  - [7. Security Considerations](#7-security-considerations)
  - [8. License](#8-license)

## 1. Abstract
This BEP introduces Super-Instructions—custom single-byte opcodes that replace high-frequency EVM opcode sequences. Contract bytecode is pre-processed off-chain to embed these opcodes, and the on-chain interpreter executes them atomically. The approach yields significant execution-layer efficiency without altering consensus rules or requiring a hard-fork.

## 2. Status

Draft

## 3. Motivation

On main-net BSC, repeated execution of identical compiler-generated instruction patterns dominates gas consumption. By fusing these hot paths into single interpreter dispatches, we:

- Reduce opcode dispatch overhead
- Minimise stack shuffling
- Achieve measurable throughput gains without protocol change, in contrast to large-scope upgrades such as BEP-141 or Shanghai-like forks

## 4. Specification

### 4.1 Optimized Bytecode Generation (Background)

| Aspect | Design |
|--------|--------|
| Feature Toggle | Node flag `--superinstu` (default false). When disabled, the optimisation pipeline becomes a no-op. |
| Workflow | codeHash lookup → LRU cache hit ⇒ use optimised code. Cache miss ⇒ (codeHash, rawCode) pushed to lock-free queue. |
| Parallelism | GOMAXPROCS / 8 worker goroutines consume the queue. |
| Basic-Block Construction | Split at PC==0 or any JUMPDEST; terminate before {JUMP, JUMPI, STOP, RETURN, REVERT, INVALID}. |
| Pattern Matching & Fusion | Sliding window (1-15 bytes) matches curated patterns; first byte replaced by custom opcode 0xb0–0xcf, trailing bytes overwritten with NOP(0x5b) to preserve length. |
| Cache | (codeHash → fusedCode) stored in in-memory LRU (64 k entries default). Auxiliary static-analysis bitvectors stored in a side-cache. |

### 4.2 Super-Instruction Execution (Foreground)

| Phase | Description |
|-------|-------------|
| Loading | Before execution, interpreter queries cache with codeHash. Hit ⇒ contract flagged optimized = true, fused bytecode loaded. Miss ⇒ original bytecode executed. |
| Dispatch | Main loop processes opcodes as usual. For newly added superinstruction opcodes, jump directly to Super-Instruction handler. |
| Semantics | Handler emulates entire sequence (e.g., AND DUP2 ADD SWAP1 DUP2 LT) in one step, adjusts PC by original length, validates jump targets when applicable. |
| Safety | If custom opcode appears in non-optimised contract, throw ErrIllegalSuperInst and revert. |

### 4.3 Super-Instruction Set Generation

| Process | Description |
|---------|-------------|
| Data-Driven Mining | Trace production traffic, extract opcode sequences, compress with Re-Pair to obtain non-repetitive string. |
| Scoring | `score = len(sequence) × frequency` |
| Overlap Resolution | Greedy graph algorithm adjusts scores when super-instructions overlap (A ⊂ B). |
| Selection | Choose Top-K sequences (32 by default) as canonical super-instruction sets. |

## 5. Compatibility & Safety
| Aspect | Guarantee |
|--------|-----------|
| Switchable | Runtime flag permits instant enable/disable without restart. |
| Length-Preserving | Fused bytecode matches original size; all offset-based tooling remains intact. |
| Consensus Neutral | Only local execution changes; on-chain code unmodified → no consensus impact. |
| Graceful Fallback | Failure in generation/execution reverts to original code path. |

## 6. Backwards Compatibility
Because bytecode length and on-chain contents remain unchanged, no tooling or contract migration is necessary. Nodes that disable the flag continue to operate identically, ensuring a smooth opt-in rollout.

## 7. Security Considerations

- **Validator Nodes**: Opt-in optimisation must not diverge state; test-suite includes differential fuzzing against vanilla EVM.
- **Custom Opcode Collision**: Range 0xb0–0xcf currently unused by London EVM; future EIPs allocating these bytes must be gated by network governance before activation.
- **DoS Risk**: Background optimiser bounded by worker pool and queue length to avoid unbounded memory/CPU spikes.

## 8. License
All the content are licensed under CC0.
