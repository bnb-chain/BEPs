```markdown
  BEP: 590
  Title: Extended Voting Rules for Fast Finality Stability
  Status: Draft
  Type: Standards
  Created: 2025-06-25
  Description: Enhance the robustness of Fast Finality by extending validator voting logic and aggregate vote inclusion rules.
```

# BEP-590: Extended Voting Rules for Fast Finality Stability

- [BEP-590: Extended Voting Rules for Fast Finality Stability](#bep-590-extended-voting-rules-for-fast-finality-stability)
    - [1. Summary](#1-summary)
    - [2. Abstract](#2-abstract)
    - [3. Motivation](#3-motivation)
    - [4. Specification](#4-specification)
      - [4.1 Validator Vote Rule 3 Changes](#41-validator-vote-rule-3-changes)
      - [4.2 Aggregate Vote Rule Changes](#42-aggregate-vote-rule-changes)
    - [5. Security](#5-security)
    - [6. Backward Compatibility](#6-backward-compatibility)
    - [7. License](#7-license)

---

### 1. Summary

This BEP proposes coordinated extensions to both the validator voting logic and aggregate vote inclusion rules in the Fast Finality (FF) protocol of the BNB Smart Chain. These changes aim to improve the stability and liveness of Fast Finality under adverse network conditions, reduce the need for throughput-limiting behaviors, and support further reductions in block interval.

---

### 2. Abstract

[BEP-126](./BEP126.md) introduced Fast Finality as a mechanism for deterministic block finalization in BNB Smart Chain. Under the original design:

* Validators always vote for the latest block
* Proposers (miners) may only aggregate votes for their direct parent block

Formally, if KAncestorGenerationDepth defines the voting and inclusion scope, then in the original design:
```
KAncestorGenerationDepth = 1
```

This BEP extends the scope by allowing `KAncestorGenerationDepth > 1`

1. **Validator Voting Rule Extension** — Allow validators to vote for blocks up to `KAncestorGenerationDepth` blocks counting from (and including) the current chain head, using the latest justified block as the vote source. This helps sustain finalization progress even when vote propagation or inclusion is delayed.
2. **Aggregate Vote Inclusion Extension** — Allow proposers to include votes for up to `KAncestorGenerationDepth` recent ancestor blocks, improving tolerance to vote propagation latency.

Together, these adjustments enhance the resilience of Fast Finality during periods of network congestion, without modifying the core consensus model or cryptographic assumptions.

---

### 3. Motivation

As transaction volume increases, validators often experience latency in receiving, verifying, and casting votes for blocks. Such delays can lead to missing justifications, which in turn hinders finalization.

To mitigate this, miners may adopt suboptimal strategies such as reducing block sizes or sealing time—both of which negatively affect throughput. Additionally, as block intervals shorten, inter-region network latency becomes a more prominent bottleneck in vote propagation.

This BEP addresses these issues by introducing:

* **Smarter validator voting logic** — to sustain finalization progress even when votes are not timely included
* **More flexible vote aggregation** — to increase the chances of including valid votes despite network delays

Together, these changes reduce finality gaps and support performance improvements without compromising safety.

---

### 4. Specification

This BEP introduces coordinated modifications to:

* **Validator Vote Rules** (Section 4.1)
* **Aggregate Vote Inclusion Rules** (Section 4.2)

---

#### 4.1 Validator Vote Rule 3 Changes

To maintain finalization even when vote inclusion is delayed, we revise `Validator Vote Rule 3` from [BEP-126](./BEP126.md) as follows:

```go
// VoteTarget determines which block a validator should vote for.
// Returns nil if no vote is needed.
func (p *Parlia) VoteTarget(chain consensus.ChainHeaderReader, curHead *types.Header) (*types.Header, error) {
	latestJustified, _, err := p.GetJustifiedNumberAndHash(chain, []*types.Header{curHead})
	if err != nil {
		return nil, err
	}
	curNum := curHead.Number.Uint64()
	depth := p.getAncestorGenerationDepth(curHead)

	// Branch 1: If the current block number is beyond justified+depth, vote for the current head
	if latestJustified+depth < curNum {
		return curHead, nil
	}

	// Branch 2: If the parent's justified number equals the current justified, no vote is required
	parent := chain.GetHeaderByHash(curHead.ParentHash)
	if parent == nil {
		return nil, errUnknownBlock
	}
	parentJustified, _, err := p.GetJustifiedNumberAndHash(chain, []*types.Header{parent})
	if err != nil {
		return nil, err
	}
	if parentJustified == latestJustified {
		return nil, nil
	}

	// Branch 3: If finalized+1 equals justified, vote for the current head
	if finalized := p.GetFinalizedHeader(chain, curHead); finalized != nil {
		if finalized.Number.Uint64()+1 == latestJustified {
			return curHead, nil
		}
	}

	// Branch 4: Check whether all intermediate blocks [latestJustified+1 .. curNum-1) can be skipped
	allSkipped := true
	for num := latestJustified + 1; num < curNum; num++ {
		hdr := chain.GetHeaderByNumber(num)
		if !p.isVotingSkippedBlock(chain, hdr) {
			allSkipped = false
			break
		}
	}
	// If all intermediate blocks are skipped, vote for latestJustified+1
	if allSkipped {
		if target := chain.GetHeaderByNumber(latestJustified + 1); target != nil {
			return target, nil
		}
	}

	// Branch 5: vote for the current head by default
	return curHead, nil
}
```

This algorithm defaults to voting for the **latest chain head**, ensuring steady progress while preserving safety:

* **Head preference** — Branches 1, 3, and 5 prioritize voting for the head to prevent inactivity and maintain liveness.
* **Finalized growth** — Branch 4 advances the finalized height by voting for `latestJustified + 1` when intermediate blocks can be skipped.
* **Vote discipline** — Branch 2 suppresses redundant votes, enabling Branch 4 to operate without violating the “one vote per height” rule.

Together, these rules balance rapid justification of the head with consistent finalization growth, improving robustness under network delays.

For example, if votes produced after verifying block N arrive during the sealing of block N+2, voting and justification progress can continue as follows:

| Block Mined | Aggregated Votes | Validator Vote (Post Verify) | Latest Justified | Latest Finalized | Rule Triggered                                                   |
| ----------- | ---------------- | ---------------------------- | ---------------- | ---------------- | ---------------------------------------------------------------- |
| 3           | -                | skip                         | 0                | 0                | Branch 2: parent justified equals latest justified → no vote       |
| 4           | -                | 0 → 4                        | 0                | 0                | Branch 1: current block far ahead → vote current head              |
| 5           | -                | 0 → 5                        | 0                | 0                | Branch 1: current block far ahead → vote current head              |
| 6           | 0 → 4            | 4 → 6                        | 4                | 0                | Branch 5: default → vote current head                              |
| 7           | -                | skip                         | 4                | 0                | Branch 2: parent justified equals latest justified → no vote       |
| 8           | 4 → 6            | 6 → 7                        | 6                | 0                | Branch 4: all intermediate blocks skipped → vote latestJustified+1 |
| 9           | -                | skip                         | 6                | 0                | Branch 2: parent justified equals latest justified → no vote       |
| 10          | 6 → 7            | 7 → 10                       | 7                | 6                | Branch 3: finalized + 1 == latest justified → vote current head    |
| 11          | -                | skip                         | 7                | 6                | Branch 2: parent justified equals latest justified → no vote       |
| 12          | 7 → 10           | 10 → 11                      | 10               | 6                | Branch 4: all intermediate blocks skipped → vote latestJustified+1 |
| 13          | -                | skip                         | 10               | 6                | Branch 2: parent justified equals latest justified → no vote       |

This update enhances protocol liveness while preserving the original safety properties.

---

#### 4.2 Aggregate Vote Rule Changes

To improve vote inclusion under delayed network conditions, this rule allows proposers to aggregate votes for recent ancestor blocks. The process proceeds in the following order:

1. Attempt to aggregate votes for the **immediate parent block**
2. If unavailable, try the **grandparent block**
3. Continue iteratively up to `KAncestorGenerationDepth` recent ancestors.

The process **must stop** once any valid vote is found and included. At most one ancestor block's votes may be included in a single proposal.

This rule gives validators up to `KAncestorGenerationDepth` block intervals to propagate their votes, improving the success rate of vote inclusion and reducing justification gaps during periods of latency.

---

### 5. Security

This BEP does **not** alter the core safety assumptions or mechanisms of Fast Finality defined in [BEP-126](./BEP126.md). Specifically, it **does not change**:

* **Validator Vote Rules 1 and 2** — which govern when and how validators may issue votes
* **Finality Rules** — including thresholds for justification and finalization
* **Longest Chain Rule** — the fork-choice rule determining canonical chain selection

This proposal only modifies:

* **Validator Vote Rule 3** — to improve finalization liveness
* **Vote aggregation scope** — to improve vote inclusion flexibility

All original safety guarantees, including one-block finality under an honest super majority, remain **intact**.

---

### 6. Backward Compatibility

This BEP is **not backward compatible** with older clients, as it changes both the validator voting logic and vote aggregation behavior. However, it introduces no changes to protocol-level message formats or user-facing APIs.

A full client upgrade across validators and block producers is required to activate the changes and maintain consensus.

---

### 7. License

The content is licensed under [Creative Commons CC0 1.0 Universal License](https://creativecommons.org/publicdomain/zero/1.0/).

---