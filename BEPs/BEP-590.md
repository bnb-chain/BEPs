```markdown
  BEP: 590
  Title: Extended Voting Rules for Fast Finality Stability
  Status: Draft
  Type: Standards
  Created: 2025-06-25
  Description: Enhance the robustness of Fast Finality by extending validator voting logic and aggregate vote inclusion rules.
```

# BEP-590: Extended Voting Rules for Fast Finality Stability

- [BEP-590: Extended Voting Rules for Fast Finality Stability](#bep-590-extended-voting-rules-for-fast-finality-stability)
    - [1. Summary](#1-summary)
    - [2. Abstract](#2-abstract)
    - [3. Motivation](#3-motivation)
    - [4. Specification](#4-specification)
      - [4.1 Validator Vote Rule 3 Changes](#41-validator-vote-rule-3-changes)
      - [4.2 Aggregate Vote Rule Changes](#42-aggregate-vote-rule-changes)
    - [5. Security](#5-security)
    - [6. Liveness](#6-liveness)
    - [7. Backward Compatibility](#7-backward-compatibility)
    - [8. License](#8-license)

---

### 1. Summary

This BEP proposes coordinated extensions to both the validator voting logic and aggregate vote inclusion rules in the Fast Finality (FF) protocol of the BNB Smart Chain. These changes aim to improve the stability and liveness of Fast Finality under adverse network conditions and support further reductions in block interval.

---

### 2. Abstract

[BEP-126](./BEP126.md) introduced Fast Finality as a mechanism for deterministic block finalization in BNB Smart Chain. Under the original design:

* Validators always vote for the latest block.
* Proposers (miners) may only aggregate votes for their direct parent block.

Formally, if `KAncestorGenerationDepth` defines the voting and inclusion scope, then in the original design:

```
KAncestorGenerationDepth = 1
```

This BEP extends the scope by allowing `KAncestorGenerationDepth > 1`:

1. **Validator Voting Rule Extension** — Validators may vote for blocks up to `KAncestorGenerationDepth` blocks counting from (and including) the current chain head, using the latest justified block as the vote source. This helps sustain finalization progress even when vote propagation or inclusion is delayed.
2. **Aggregate Vote Inclusion Extension** — Proposers may include votes for up to `KAncestorGenerationDepth` recent ancestor blocks, improving tolerance to vote propagation latency.

Together, these adjustments enhance the resilience of Fast Finality during periods of network congestion, without modifying the core consensus model or cryptographic assumptions.

---

### 3. Motivation

Validators can experience latency in receiving, verifying, and casting votes for blocks. Such delays may lead to missing justifications, which in turn hinders finalization.

Additionally, as block intervals shorten, inter-region network latency becomes a more prominent bottleneck in vote propagation.

This BEP addresses these issues by introducing:

* **Smarter validator voting logic** — to sustain finalization progress even when votes are not timely arrived.
* **More flexible vote aggregation** — to increase the chances of including valid votes despite network delays.

---

### 4. Specification

This BEP introduces coordinated modifications to:

* **Validator Vote Rules** (Section 4.1)
* **Aggregate Vote Inclusion Rules** (Section 4.2)

---

#### 4.1 Validator Vote Rule 3 Changes

To maintain finalization even when vote inclusion is delayed, we revise `Validator Vote Rule 3` from [BEP-126](./BEP126.md) as follows:

```go
// VoteTarget determines which block a validator should vote for.
// Returns nil if no vote is needed.
func (p *Parlia) VoteTarget(chain consensus.ChainHeaderReader, curHead *types.Header) (*types.Header, error) {
	latestJustified, _, err := p.GetJustifiedNumberAndHash(chain, []*types.Header{curHead})
	if err != nil {
		return nil, err
	}
	curNum := curHead.Number.Uint64()
	depth := p.getAncestorGenerationDepth(curHead)

	// Branch 1: If the current block number is beyond justified+depth or the next block of latestJustified , vote for the current head
	if latestJustified+depth < curNum {
		return curHead, nil
	}

	// Branch 2: If the parent's justified number equals the current justified, no vote is required
	parent := chain.GetHeaderByHash(curHead.ParentHash)
	if parent == nil {
		return nil, errUnknownBlock
	}
	parentJustified, _, err := p.GetJustifiedNumberAndHash(chain, []*types.Header{parent})
	if err != nil {
		return nil, err
	}
	if parentJustified == latestJustified {
		return nil, nil
	}

	// Branch 3: If finalized+1 equals justified, vote for the current head
	if finalized := p.GetFinalizedHeader(chain, curHead); finalized != nil {
		if finalized.Number.Uint64()+1 == latestJustified {
			return curHead, nil
		}
	}

	// Branch 4: Check whether all intermediate blocks [latestJustified+1 .. curNum-1) can be skipped
	allSkipped := true
	for num := latestJustified + 1; num < curNum; num++ {
		hdr := chain.GetHeaderByNumber(num)
		if !p.isVotingSkippedBlock(chain, hdr) {
			allSkipped = false
			break
		}
	}
	// If all intermediate blocks are skipped, vote for latestJustified+1
	if allSkipped {
		if target := chain.GetHeaderByNumber(latestJustified + 1); target != nil {
			return target, nil
		}
	}

	// Branch 5: vote for the current head by default
	return curHead, nil
}
```

This algorithm defaults to voting for the **latest chain head**, ensuring steady progress while preserving safety:

* **Head preference** — Branches 1, 3, and 5 prioritize voting for the head to prevent inactivity and maintain liveness.
* **Finalized growth** — Branch 4 advances the finalized height by voting for `latestJustified + 1` when intermediate blocks have be skipped.
* **Vote discipline** — Branch 2 suppresses redundant votes, enabling Branch 4 to operate without violating the “one vote per height” rule.

It is also evident that this algorithm ensures the **voter target number is monotonically increasing**.
Together, these rules balance rapid justification of the head with consistent finalized height growth, improving robustness under network delays.

For example, if votes produced after verifying block N arrive during the sealing of block N+2, voting and justification progress can continue as follows:

| Block Mined | Aggregated Votes | Validator Vote (Post Verify) | Latest Justified | Latest Finalized | Rule Triggered                                                   |
| ----------- | ---------------- | ---------------------------- | ---------------- | ---------------- | ---------------------------------------------------------------- |
| 3           | -                | skip                         | 0                | 0                | Branch 2: parent justified equals latest justified → no vote       |
| 4           | -                | 0 → 4                        | 0                | 0                | Branch 1: current block far ahead → vote current head              |
| 5           | -                | 0 → 5                        | 0                | 0                | Branch 1: current block far ahead → vote current head              |
| 6           | 0 → 4            | 4 → 6                        | 4                | 0                | Branch 5: default → vote current head                              |
| 7           | -                | skip                         | 4                | 0                | Branch 2: parent justified equals latest justified → no vote       |
| 8           | 4 → 6            | 6 → 7                        | 6                | 0                | Branch 4: all intermediate blocks skipped → vote latestJustified+1 |
| 9           | -                | skip                         | 6                | 0                | Branch 2: parent justified equals latest justified → no vote       |
| 10          | 6 → 7            | 7 → 10                       | 7                | 6                | Branch 3: finalized + 1 == latest justified → vote current head    |
| 11          | -                | skip                         | 7                | 6                | Branch 2: parent justified equals latest justified → no vote       |
| 12          | 7 → 10           | 10 → 11                      | 10               | 6                | Branch 4: all intermediate blocks skipped → vote latestJustified+1 |
| 13          | -                | skip                         | 10               | 6                | Branch 2: parent justified equals latest justified → no vote       |
| 14          | 10 → 11          | 11 → 14                      | 11               | 10               | Branch 3: finalized + 1 == latest justified → vote current head    |

---

#### 4.2 Aggregate Vote Rule Changes

To improve vote inclusion under delayed network conditions, proposers are allowed to aggregate votes for recent ancestor blocks. The process follows this priority sequence:

1. Attempt to aggregate votes for the **immediate parent block**.
2. If unavailable, try the **grandparent block**.
3. Continue iteratively up to `KAncestorGenerationDepth` recent ancestors.

The process **terminates immediately** once any valid vote is included. At most **one ancestor block’s votes** may be aggregated in a single proposal.

This rule gives validators up to `KAncestorGenerationDepth` block intervals to propagate their votes, improving the success rate of vote inclusion and reducing justification gaps during periods of network latency.

---

### 5. Security

This BEP does **not** alter the core safety assumptions or mechanisms of Fast Finality defined in [BEP-126](./BEP126.md). Specifically, it **does not change**:

* **Validator Vote Rules 1 and 2** — governing when and how validators may issue votes.
* **Finality Rules** — including thresholds for justification and finalization.
* **Longest Chain Rule** — the fork-choice rule determining canonical chain selection.

This proposal only modifies:

* **Validator Vote Rule 3** — to improve finalization liveness.
* **Vote aggregation scope** — to improve vote inclusion flexibility.

All original safety guarantees, including one-block finality under an honest super majority, remain **intact**.

---

### 6. Liveness

Assume that a vote generated upon receiving block **N** can only be received by other validators when block **N + D** is produced. We refer to **D** as the **vote propagation delay**.

* When the block interval is large, typically **D = 1**:

  * A block requires **1 subsequent block** to become justified.
  * And **2 subsequent blocks** to become finalized.

* As the block interval decreases or the GasLimit increases, **D** grows. Votes alternate between **justifying the latest head** and **advancing the finalized height**.

| Metric                 | Lag behind latest head (blocks) | Average    |
| ---------------------- | ------------------------------- | ---------- |
| Justified block number | `[D ... 2D-1, 2D-1 ... 3D-2]`   | `2D-1`     |
| Finalized block number | `[2D ... 4D-1]`                 | `3D - 1/2` |

Additionally, to ensure continuous growth of the finalized block number:

```
KAncestorGenerationDepth + 1 ≥ 2D
```

---

### 7. Backward Compatibility

This BEP is **not backward compatible** with older clients, as it changes both the validator voting logic and vote aggregation behavior. However, it introduces no changes to protocol-level message formats or user-facing APIs.

A full client upgrade across validators and block producers is required to activate the changes and maintain consensus.

---

### 8. License

The content is licensed under [Creative Commons CC0 1.0 Universal License](https://creativecommons.org/publicdomain/zero/1.0/).